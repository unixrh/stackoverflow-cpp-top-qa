## [在C++中，指针变量和引用变量有何不同？](https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in)

### 问题
引用算是语法糖，使用它可以让代码读写都更加友好，但区别具体在哪里呢？

----
整理答案如下：
1. 指针变量可以重新赋值任意次；引用类型绑定之后就不能重新赋值；
2. 指针可以指向空（`NULL`）；引用必须指向一个对象；
3. 你可以获得指针地址；但是不能获得引用的地址；
4. 你可以拿着对象的指针最算术运算；引用不行；

澄清一个误解：
> C ++标准非常谨慎，以避免规定编译器如何实现引用，但每个C ++编译器都将引用实现为指针。
也就是说，这样的一个声明 `int &ri = i;`，如果不作完全优化，将分配与指针同等大小的存储，并将`i`的地址置于其中。

**因此，引用和指针将占据同样大小的内存空间。**

通用规则：
- 在函数参数以及返回类型中使用引用，这样更容易实现有用并且自说明的接口；
- 在实现算法和数据结构时使用指针；

### [回答1](https://stackoverflow.com/a/57492)
1. 指针可以被重新赋值：
```c++
int x = 5;
int y = 6;
int *p;
p =  &x;
p = &y;
*p = 10;
assert(x == 5);
assert(y == 10);
```
但是引用不行，并且必须在初始化时被赋值：
```c++
int x = 5;
int y = 6;
int &r = x;
```
2. 指针在堆栈上有自己的内存地址和大小（x86上为4个字节），而引用共享相同的内存地址（与原始变量共享），但也会占用堆栈上的一些空间。由于引用与原始变量本身具有相同的地址，因此可以将引用视为同一变量的别名。 注意：指针指向的内容可以在堆或栈上，栈也一样。 我在这个陈述中的主张并不是指针必须指向栈。 指针只是一个保存内存地址的变量。 此变量位于栈上。 由于引用在栈上有自己的空间，并且地址与它引用的变量相同（看这里可以了解更多[关于栈与堆](https://stackoverflow.com/questions/79923/what-and-where-are-the-stack-and-heap#79936)）。 这意味着编译器向你隐瞒了一个引用的实际地址。
```c++
int x = 0;
int &r = x;
int *p = &x;
int *p2 = &r;
assert(p == p2);
```
3. 你可以使用多级指针来获得多层间接的级别。 而引用仅提供层。
```c++
int x = 0;
int y = 0;
int *p = &x;
int *q = &y;
int **pp = &p;
pp = &q; //*pp = q
**pp = 4;
assert(y == 4);
assert(x == 0);
```
4. 指针可以直接被赋值为`nullptr`，但是引用不行。如果你足够努力，你可以让一个引用的地址变为`nullptr`。同样地，如果你足够努力，你可以拥有指针的引用，这样引用就能包含`nullptr`了。
```c++
int *p = nullptr;
int &r = nullptr; <--- 编译错误
int &r = *p;  <--- 很可能不会编译出错，尤其当`nullptr`是藏在函数调用中时，但它实际上指向一个不存在的整型。
```
5. 指针可以遍历数组，你可以使用`++`转到指针指向的下一个元素，`+4`转到第5个元素。 无论指针指向的对象大小如何。
6. 需要使用`*`使得指针访问它指向的内存位置，而可以引用则可以直接使用。 指向类/结构的指针使用`->`来访问它的成员，而引用则使用`.`。
7. 指针是保存内存地址的变量。无论引用如何实现，引用都具有与其引用的项相同的内存地址。
8. 引用不能填充到数组中，而指针可以。
9. Const引用可以绑定到临时值，而指针一般不能：
```c++
const int &x = int(12); // 合法的 C++
int *y = &int(12); // 访问临时值的方式非法
```

#### 评论
- `2` 有误。引用不是简单地*同一个变量的别名*。引用可以传递给函数，存储于类中等等，某种程度上非常类似于指针。他们都独立地存在于他们只想的变量之外。
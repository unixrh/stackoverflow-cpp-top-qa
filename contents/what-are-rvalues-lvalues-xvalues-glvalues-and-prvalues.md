## [`rvalues` `lvalues` `xvalues` `glvalues` `prvalues` 分别是什么？](https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues)

### 问题
C++03时，只有`rvalue`和`lvalue`。
而在C++11中，一个表达式可以是 `rvalues` `lvalues` `xvalues` `glvalues` `prvalues`。
种类由2种变成了5种。

- 这些新的表达式是种类是什么意思？
- 这些新的表达式和早先的两种有什么关联？
- `rvalue`和`lvalue` 与早先的一致吗？
- 为什么需要这些新的种类呢？

### [回答1](https://stackoverflow.com/a/3601661/3533902)
这里有个[文档](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2010/n3055.pdf)，有更详细的说明。

整个大改动始于`move`语义。一旦我们有可以移动而不是复制的表达式，很显然就要求区分哪些表达式可以移动，以及在哪个方向上移动。

就我所知而言，`rvalue`和`lvalue` 与早先一致，但涉及到移动语义时，事情稍微棘手一些。

关于是否需要新种类的问题，如果我们不想要新特性，那当然不是必须。但为了更好地优化代码，我们最好还是拥抱变化吧。

- 左值（可以出现在赋值表达式的左侧）指定函数或对象。 *示例：如果`E`是指针类型的表达式，则`*E`是指向`E`对应的对象或函数的左值表达式。 另一个例子，调用返回类型为左值引用的函数，调用结果是左值。*
- `xvalue`*将过期值*，也指向一个对象，一般用在对象的生命周期要结束的时候（以便它的原数据可以被`move`）。*将过期值*，一般是与右值引用有关的表达式产生的结果。*示例：调用一个返回类型为右值引用的函数，调用结果就是*将过期值*。*
- `glvalue` - 生成的左值，它可以是左值或者*将过期值*。
- 右值，顾名思义是可以出现在赋值表达式右边的值，它是一个*将过期值*，也就是一个临时的对象，或者是一个与对象无关的值。
- `prvalue` 纯右值，是一个非*将过期值*的右值。*示例：调用返回类型为非引用的函数，调用结果为纯右值*。
## [C++11引入了标准化的内存模型，这意味着什么，这将如何影响Ｃ++编程？](https://stackoverflow.com/questions/6319146/c11-introduced-a-standardized-memory-model-what-does-it-mean-and-how-is-it-g)
### 问题
C++11引入了标准化的内存模型，但准确地说这意味着什么呢？这将如何影响Ｃ++编程呢？
有一篇[文章](http://www.theregister.co.uk/2011/06/11/herb_sutter_next_c_plus_plus/page2.html)（作者
是Gavin Clarke，他引用[Herb Sutter](https://en.wikipedia.org/wiki/Herb_Sutter)）说道：
> 内存模型意味着，无论使用何种编译器或者在何种平台上运行，C++ 代码都有一个标准库可供调用。
有一种标准的方式来控制不同的线程如何与处理器的内存进行通信。

> ”当说道将代码按标准分割再不同的核心上时，我们说的就是内存模型。我们会在不破坏以下假设的基础上，对它进行优化。“ Sutter说道。

当然我可以记住这些以及网络上类似的文章（我自打出生以来就有自己的记忆模型），甚至于可以回答别人问的相关问题。
但说实话，我并不确切地理解这些。

C++程序员以前就开发多线程应用，所以是POSIX线程或者Windows线程，或是C++11线程，这有什么关系呢？它的好处在哪里？我想了解底层的细节。

我不清楚多线程的底层是如何工作的，也不清楚通常意义上的内存模型是什么意思，请帮我理解这些概念。

### [回答1](https://stackoverflow.com/a/6319356)

首先，你必须学着像个语言律师那样思考。

C++11的标准并不参考任何特定的编译器、操作系统或者CPU。它参考的是一个通常系统对应的抽象机器。
在语言律师的世界中，程序员的工作就是为抽象机器写代码，编译器的工作就是将代码实现在具体的机器上。
严格参照标准写代码，就能保证不论是今天还是50年后，你的代码能够不经修改地在任何系统上通过兼容的C++编译器来编译和运行。

C++98/C++03标准中的抽象机器基本上是单线程的，因此无法写出处处可用的多线程代码。
该规范甚至没有说明内存加载和存储的原子性或加载和存储可能发生的顺序，更不用说像互斥体这样的东西了。

当然，你在实践中可以为特定的具体系统写多线程代码——比如pthreads或者Windows，但是C++98/C++03并没有一个标准的方式来写多线程代码。

C++11的抽象机器就设计为了多线程，同时具备良好定义的内存模型，也就是说，它规定了当涉及到访问内存时，编译器能做啥不能做啥。

考虑下面这个例子，当一对全局变量被并发的两个线程访问：
```C++
           Global
           int x, y;

Thread 1            Thread 2
x = 17;             cout << y << " ";
y = 37;             cout << x << endl;
```
